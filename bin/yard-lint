#!/usr/bin/env ruby
# frozen_string_literal: true

$LOAD_PATH.unshift File.expand_path('../lib', __dir__)

require 'optparse'
require 'yard-lint'

options = {}
config_file = nil
diff_mode = nil

OptionParser.new do |opts|
  opts.banner = 'Usage: yard-lint [options] PATH'

  opts.on('-c', '--config FILE', 'Path to config file (default: .yard-lint.yml)') do |file|
    config_file = file
  end

  opts.on('-f', '--format FORMAT', 'Output format (text, json)') do |format|
    options[:format] = format
  end

  opts.on('-q', '--quiet', 'Quiet mode (only show summary)') do
    options[:quiet] = true
  end

  opts.on('--stats', 'Show statistics summary') do
    options[:stats] = true
  end

  opts.on('--min-coverage PERCENT', Float, 'Minimum documentation coverage required (0-100)') do |percent|
    options[:min_coverage] = percent
  end

  opts.on('--[no-]progress', 'Show progress indicator (default: auto)') do |value|
    options[:progress] = value
  end

  opts.separator ''
  opts.separator 'Diff mode options (mutually exclusive):'

  opts.on('--diff [REF]', 'Lint only files changed since REF (default: main/master auto-detected)') do |ref|
    diff_mode = { mode: :ref, base_ref: ref }
  end

  opts.on('--staged', 'Lint only staged files (git index)') do
    diff_mode = { mode: :staged }
  end

  opts.on('--changed', 'Lint only uncommitted files') do
    diff_mode = { mode: :changed }
  end

  opts.separator ''
  opts.separator 'Other options:'

  opts.on('--init', 'Generate .yard-lint.yml config file with defaults') do
    options[:init] = true
  end

  opts.on('--force', 'Force overwrite when using --init') do
    options[:force] = true
  end

  opts.on('-v', '--version', 'Show version') do
    puts "yard-lint #{Yard::Lint::VERSION}"
    exit
  end

  opts.on('-h', '--help', 'Show this help') do
    puts opts
    puts
    puts 'Examples:'
    puts '  yard-lint lib/                          # Lint all files in lib/'
    puts '  yard-lint --diff main lib/              # Lint only files changed since main branch'
    puts '  yard-lint --staged lib/                 # Lint only staged files'
    puts '  yard-lint --changed lib/                # Lint only uncommitted files'
    puts '  yard-lint --format json lib/            # Output in JSON format'
    exit
  end
end.parse!

# Handle --init flag
if options[:init]
  if Yard::Lint::ConfigGenerator.generate(force: options[:force])
    puts 'Created .yard-lint.yml with default configuration'
    exit 0
  else
    puts 'Error: .yard-lint.yml already exists'
    puts 'Use --init --force to overwrite'
    exit 1
  end
end

# Get path argument
path = ARGV[0]

unless path
  puts 'Error: PATH argument is required'
  puts 'Usage: yard-lint [options] PATH'
  exit 1
end

# Clear YARD database and command cache to ensure fresh run on each CLI invocation
#
# Why this is necessary:
#
# 1. **Command Cache Reset** (`reset_command_cache!`)
#    - The command cache stores results from YARD commands across validator instances
#    - This cache is shared at the class level (Base.@shared_command_cache)
#    - Without reset: Results from a previous CLI run could leak into the current run
#    - Critical for CLI: Each `yard-lint` invocation should start with clean state
#    - Not needed in-process: Within a single run, caching YARD results is beneficial
#
# 2. **YARD Database Clear** (`clear_yard_database!`)
#    - YARD creates temp database directories for parsing documentation
#    - Directories are isolated per-argument-set using SHA256 hash (see base.rb:84-97)
#    - Base temp dir (YARDOC_BASE_TEMP_DIR) persists across CLI invocations
#    - Without clear: Old databases accumulate in /tmp, wasting disk space
#    - Database isolation prevents contamination within a single run, but doesn't
#      clean up between runs
#
# In summary: These ensure each CLI invocation is independent and doesn't leak state
# from previous runs, while also preventing temp directory accumulation.
Yard::Lint::Validators::Base.reset_command_cache!
Yard::Lint::Validators::Base.clear_yard_database!

# Load config and apply CLI overrides
config = if config_file
           Yard::Lint::Config.from_file(config_file)
         else
           Yard::Lint::Config.load || Yard::Lint::Config.new
         end

# Apply CLI min_coverage override if provided
config.min_coverage = options[:min_coverage] if options[:min_coverage]

# Run the linter
begin
  result = Yard::Lint.run(
    path: path,
    config: config,
    progress: options[:progress],
    diff: diff_mode
  )
rescue Yard::Lint::Git::Error => e
  puts "Git error: #{e.message}"
  exit 1
end

# Format and display results
case options[:format]
when 'json'
  require 'json'
  puts JSON.pretty_generate({
    offense_count: result.count,
    offenses: result.offenses
  })
  exit result.exit_code
when 'text', nil
  # Calculate coverage stats if requested or configured
  coverage = result.documentation_coverage if options[:stats] || options[:min_coverage] || config.min_coverage

  # Show coverage stats if available
  if coverage && (options[:stats] || options[:quiet])
    puts "\nDocumentation Coverage: #{coverage[:coverage].round(2)}%"
    puts "  Total objects:      #{coverage[:total]}"
    puts "  Documented:         #{coverage[:documented]}"
    puts "  Undocumented:       #{coverage[:total] - coverage[:documented]}"

    if config.min_coverage
      if coverage[:coverage] >= config.min_coverage
        puts "  Status:             ✓ Meets minimum (#{config.min_coverage}%)"
      else
        puts "  Status:             ✗ Below minimum (#{config.min_coverage}%)"
      end
    end
    puts
  end

  if result.clean?
    # Still check coverage requirement even if no offenses
    if coverage && config.min_coverage && coverage[:coverage] < config.min_coverage
      puts "Error: Documentation coverage #{coverage[:coverage].round(2)}% is below minimum #{config.min_coverage}%"
      exit result.exit_code
    end

    puts 'No offenses found' unless options[:quiet]
    exit 0
  else
    # Show statistics if requested or in quiet mode
    if options[:stats] || options[:quiet]
      stats = result.statistics
      puts "#{result.count} offense(s) detected"
      puts "  Errors:      #{stats[:error]}"
      puts "  Warnings:    #{stats[:warning]}"
      puts "  Conventions: #{stats[:convention]}"
      puts
    end

    # Show individual offenses unless in quiet mode
    unless options[:quiet]
      puts "Found #{result.count} offense(s):\n\n"

      result.offenses.each do |offense|
        severity_symbol = case offense[:severity]
                          when 'error' then 'E'
                          when 'warning' then 'W'
                          when 'convention' then 'C'
                          else '?'
                          end

        puts "[#{severity_symbol}] #{offense[:location]}:#{offense[:location_line]}"
        puts "    #{offense[:name]}: #{offense[:message]}"
        puts
      end
    end

    exit result.exit_code
  end
else
  puts "Error: Unknown format '#{options[:format]}'"
  exit 1
end
